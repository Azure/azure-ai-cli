# ME: Can you show me an example of using the Text Template Transformation Toolkit?

Certainly! T4 (Text Template Transformation Toolkit) is a code generation engine built into Visual Studio for C# and VB.NET projects. It uses text templates with embedded C# or VB.NET code to generate code files during build or on-demand. Let's walk through a simple example of using T4 in a C# project to generate a basic class.

1. Create a new C# project in Visual Studio (Console Application, Class Library, etc.).
2. Right-click on the project in the Solution Explorer, go to "Add," and then choose "New Item."
3. In the "Add New Item" dialog, select "Text Template" from the "General" category and give it a meaningful name (e.g., "ExampleT4Template.tt").
4. Once you add the Text Template, you will see the template editor in Visual Studio.
5. Replace the default content with the following T4 template code:

```csharp
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>

using System;

namespace MyNamespace
{
    public class MyGeneratedClass
    {
        public void MyMethod()
        {
            Console.WriteLine("Hello, World! This code is generated by T4.");
        }
    }
}
```

6. Save the template file (ExampleT4Template.tt).
7. Right-click on the template file in the Solution Explorer and choose "Run Custom Tool."
8. This will generate a new C# file with the same name as the template file but with the ".cs" extension (ExampleT4Template.cs).
9. Now, you should see the generated code file (ExampleT4Template.cs) in the Solution Explorer.
10. You can use this generated class in your C# project like any other class.

Whenever you need to update the generated code, simply make changes to the T4 template file and run the "Run Custom Tool" command again to regenerate the code file.

T4 templates can be much more sophisticated and powerful than this simple example. They can include loops, conditional statements, and pull data from various sources like databases, XML files, or other custom data structures.

Remember that T4 templates (.tt files) do not directly execute like regular C# code; instead, Visual Studio processes them during build or on-demand to generate the output code. This makes them a useful tool for repetitive code generation tasks, reducing boilerplate code, and ensuring consistency across your projects.

# ME: Can i make complex conditions to decide if a particular block of code should be emitted or not?

Yes, you can absolutely create complex conditions in T4 templates to decide whether a particular block of code should be emitted or not. T4 templates support embedded C# or VB.NET code, which means you have the full power of these programming languages at your disposal to implement conditional logic.

Here's an example of how you can use complex conditions in a T4 template:

Let's say you want to generate code for a class with different methods based on some options. For this example, let's consider two options: "HasMethodA" and "HasMethodB." If both options are selected, the generated class will have both methods. If only one of them is selected, only the corresponding method will be included.

1. Start with the same setup as before, creating a new Text Template file (ExampleT4Template.tt).
2. Replace the content of the template file with the following code:

```csharp
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>

using System;

namespace MyNamespace
{
    public class MyGeneratedClass
    {
<# if (HasMethodA) { #>
        public void MethodA()
        {
            Console.WriteLine("Method A is generated by T4.");
        }
<# } #>

<# if (HasMethodB) { #>
        public void MethodB()
        {
            Console.WriteLine("Method B is generated by T4.");
        }
<# } #>
    }
}
```

3. Before you run the custom tool to generate the code, define the boolean options "HasMethodA" and "HasMethodB" in the template's properties. To do this:
   - Right-click on the template file (ExampleT4Template.tt) in the Solution Explorer.
   - Select "Properties" from the context menu.
   - In the Properties window, you'll see a set of custom properties for the template.
   - Add two boolean properties: "HasMethodA" and "HasMethodB," and set their values as needed.
4. Run the "Run Custom Tool" command on the template file (ExampleT4Template.tt) to generate the output code file (ExampleT4Template.cs).

Depending on the values you set for "HasMethodA" and "HasMethodB," the generated class will include the respective methods.

This example demonstrates how you can use if-conditions in T4 templates to conditionally emit blocks of code. You can make the conditions as complex as you need, using logical operators (&&, ||, !) and any other C# or VB.NET constructs to control the code generation process based on various options and conditions.

# ME: so content inside the `<#` and `#>` are actually valid C# code?

Yes, exactly! Content inside the `<#` and `#>` tags in T4 templates is valid C# or VB.NET code, depending on the language you are using for the template (C# is used in the examples provided earlier). This code is executed during the T4 template transformation process.

The T4 template engine interprets the embedded code within those tags and generates output based on the logic defined. This allows you to use all the features and constructs of C# or VB.NET to perform complex operations, including:

- **Conditional Statements:** Use `if`, `else if`, `else`, `switch`, etc., to control the flow of code generation based on conditions.
- **Loops:** Use `for`, `foreach`, `while`, etc., to iterate over collections or repeat code blocks.
- **Variables and Expressions:** Declare and use variables, perform calculations, and build dynamic output based on various factors.
- **Function Calls:** Invoke functions and methods to reuse common logic or manipulate data.
- **Importing Namespace:** Use `using` or `Imports` statements to import namespaces as needed.

Here's another example to demonstrate the use of a loop in a T4 template:

```csharp
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>

using System;

namespace MyNamespace
{
    public class MyGeneratedClass
    {
<# for (int i = 1; i <= 5; i++) { #>
        public void Method<#= i #>()
        {
            Console.WriteLine($"Method <#= i #> is generated by T4.");
        }
<# } #>
    }
}
```

In this example, a `for` loop is used to generate five different methods with names Method1, Method2, Method3, Method4, and Method5.

Remember that the output of the T4 template is the result of executing the C# code within the tags, and it will be included in the final code generation output. T4 templates offer a powerful way to dynamically generate code based on various factors and can be extremely useful for code generation tasks.

# ME: That's super cool. Now, instead of using this from within visual studio, can I write an app that uses this facility itself, with TT files that it might find not on the local disk? 

Yes, you can definitely write an application that uses the T4 template transformation facility without relying on Visual Studio, and it can process TT files from various sources, not just from the local disk. This allows you to build custom code generation tools or integrate code generation into your applications or build processes.

To achieve this, you need to use the T4 Engine to perform the template transformation programmatically. The T4 Engine is part of the Microsoft.VisualStudio.TextTemplating namespace and provides the necessary APIs to execute T4 templates outside of Visual Studio.

Here's a high-level overview of the steps you would take to use the T4 Engine in your application:

1. **Install NuGet Package:**
   In your application, install the NuGet package `Microsoft.VisualStudio.TextTemplating` to get access to the T4 Engine.
2. **Load and Process TT Files:**
   Your application can load TT files from various sources such as files on the local disk, resources, or even dynamically generated templates from a database or remote server.
3. **Instantiate T4 Template Engine:**
   Create an instance of the `Microsoft.VisualStudio.TextTemplating.Engine` class to access the T4 template engine.
4. **Configure Host and HostSpecific properties:**
   Create an instance of the `Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost` interface to configure the host environment for template transformation. The host can provide context and settings that are typically provided by Visual Studio when running templates.
5. **Set Template Parameters:**
   If your TT file uses custom properties or parameters (like the "HasMethodA" and "HasMethodB" properties in the previous example), you need to set those parameters before transformation. You can do this using the `Microsoft.VisualStudio.TextTemplating.Engine.SetParameter` method.
6. **Run Transformation:**
   Call the `Microsoft.VisualStudio.TextTemplating.Engine.ProcessTemplate` method to run the transformation process. This will execute the embedded C# code in the TT file and generate the output.
7. **Retrieve Output:**
   After transformation, you can retrieve the generated code as a string using the `Microsoft.VisualStudio.TextTemplating.Engine.ProcessTemplate` method.

By following these steps, you can build a code generation tool or application that leverages the power of T4 templates and can process TT files from various sources, making it versatile and flexible for different use cases.

Keep in mind that the specific implementation details and APIs may vary slightly depending on the version of the T4 Engine you're using, but the core concepts should remain consistent.

# ME: Can you write an example console tool that accepts a TT file as the first and only command line parameter, that does all that above?

Sure! Below is an example of a C# console application that accepts a TT (Text Template) file as a command-line parameter, processes the template using the T4 Engine, and outputs the generated code to the console.

Before running this example, make sure to install the `Microsoft.VisualStudio.TextTemplating` NuGet package in your project.

```csharp
using System;
using System.IO;
using Microsoft.VisualStudio.TextTemplating;

namespace T4ConsoleTool
{
    class Program
    {
        static void Main(string[] args)
        {
            if (args.Length == 0)
            {
                Console.WriteLine("Please provide the path to the TT file as a command-line argument.");
                return;
            }

            string ttFilePath = args[0];

            if (!File.Exists(ttFilePath))
            {
                Console.WriteLine("The specified TT file does not exist.");
                return;
            }

            // Load the TT template content from the file
            string templateContent = File.ReadAllText(ttFilePath);

            // Create the T4 Engine
            Engine engine = new Engine();

            // Create a custom host to provide settings and context for template transformation
            CustomTextTemplatingHost host = new CustomTextTemplatingHost();
            
            // Set any custom parameters that your template requires
            host.SetParameter("HasMethodA", true);
            host.SetParameter("HasMethodB", false);

            // Perform the template transformation
            string generatedCode = engine.ProcessTemplate(templateContent, host);

            // Output the generated code to the console
            Console.WriteLine(generatedCode);
        }
    }

    // Custom Text Templating Host to provide context and settings
    public class CustomTextTemplatingHost : ITextTemplatingEngineHost
    {
        // Implement any required methods and properties from the ITextTemplatingEngineHost interface
        // For this example, we only need to implement the following two methods.

        public string ResolveAssemblyReference(string assemblyReference)
        {
            // This method is used to resolve assembly references if your template uses custom assemblies.
            // For this example, we don't need to resolve any custom assembly references, so we return null.
            return null;
        }

        public Type ResolveDirectiveProcessor(string processorName)
        {
            // This method is used to resolve custom directive processors.
            // If your template uses custom directives, you can implement the logic to resolve them here.
            // For this example, we don't have any custom directive processors, so we return null.
            return null;
        }

        // You can add more methods and properties from the ITextTemplatingEngineHost interface as needed.
        // For simple scenarios, the two methods above are sufficient.
    }
}
```

With this console application, you can run it from the command line like this:

```
T4ConsoleTool.exe path\to\your\Template.tt
```

Replace `T4ConsoleTool.exe` with the name of your compiled executable. The console application will load the TT file, perform the template transformation, and output the generated code to the console.

Please note that this is a basic example to demonstrate the core functionality of using the T4 Engine programmatically. In a more robust implementation, you might want to handle errors, provide more options for setting parameters, and improve the custom Text Templating Host as needed based on your specific use case.

# ME: can you give me an example of a directive? and then do a simple implementation of that?

Sure! In T4 templates, directives are special instructions that provide metadata and configuration for the template transformation process. Directives are defined using special syntax and are enclosed in `<#@ ... #>` tags. One common directive is the `template` directive, which provides settings for the template itself.

Let's define a custom directive called `Title`, which will allow us to specify a title for the generated class in our T4 template.

Here's how the directive would look in the T4 template:

```csharp
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ parameter name="Title" type="System.String" #>

using System;

namespace MyNamespace
{
    public class <#= Title #> // Use the 'Title' directive parameter
    {
        public void MyMethod()
        {
            Console.WriteLine("Hello, World! This code is generated by T4.");
        }
    }
}
```

In this example, we defined a `Title` directive parameter that allows us to specify the title for the generated class. We'll need to implement the custom directive processor to handle this directive and provide the desired value for the `Title` parameter.

Now, let's implement the custom directive processor in the console application:

```csharp
using System;
using System.IO;
using Microsoft.VisualStudio.TextTemplating;

namespace T4ConsoleTool
{
    class Program
    {
        static void Main(string[] args)
        {
            if (args.Length == 0)
            {
                Console.WriteLine("Please provide the path to the TT file as a command-line argument.");
                return;
            }

            string ttFilePath = args[0];

            if (!File.Exists(ttFilePath))
            {
                Console.WriteLine("The specified TT file does not exist.");
                return;
            }

            // Load the TT template content from the file
            string templateContent = File.ReadAllText(ttFilePath);

            // Create the T4 Engine
            Engine engine = new Engine();

            // Create a custom host to provide settings and context for template transformation
            CustomTextTemplatingHost host = new CustomTextTemplatingHost();
            
            // Set custom parameter values for the Title directive
            host.SetParameter("Title", "MyGeneratedClass");

            // Perform the template transformation
            string generatedCode = engine.ProcessTemplate(templateContent, host);

            // Output the generated code to the console
            Console.WriteLine(generatedCode);
        }
    }

    // Custom Text Templating Host to provide context and settings
    public class CustomTextTemplatingHost : ITextTemplatingEngineHost
    {
        // Implement the ResolveDirectiveProcessor method to handle custom directive 'Title'
        public Type ResolveDirectiveProcessor(string processorName)
        {
            if (processorName == "Title")
            {
                return typeof(CustomDirectiveProcessor);
            }

            return null;
        }

        // Other ITextTemplatingEngineHost interface methods and properties can remain the same from the previous example.
    }

    // Custom Directive Processor to handle the 'Title' directive
    public class CustomDirectiveProcessor : DirectiveProcessor
    {
        public override void ProcessDirective(string directiveName, IDictionary<string, string> arguments)
        {
            // In this example, we'll only handle the 'Title' directive
            if (directiveName == "Title")
            {
                // Check if the directive has a 'value' argument
                if (arguments.TryGetValue("value", out string title))
                {
                    // Set the value of the 'Title' parameter in the custom Text Templating Host
                    Host.SetParameter("Title", title);
                }
            }
        }
    }
}
```

In this implementation, the `ResolveDirectiveProcessor` method in the `CustomTextTemplatingHost` class is responsible for determining which custom directive processor to use based on the directive's name. When it encounters the `Title` directive, it returns the `CustomDirectiveProcessor` type, which handles the processing logic.

The `CustomDirectiveProcessor` class inherits from `DirectiveProcessor` and overrides the `ProcessDirective` method. In this method, we check if the directive is `Title`, retrieve the value provided in the directive using the `value` argument, and then set the value of the `Title` parameter in the custom Text Templating Host.

With this setup, you can use the `Title` directive in your T4 template to specify the desired title for the generated class, and the custom directive processor will handle it during the template transformation process.

Remember that this is a basic example to demonstrate custom directive processing. In a more complete implementation, you might want to handle errors, support more complex directives, and add additional custom logic based on your specific use case.

# NOT from GPT, but interesting

Looks like there's a newer one built from the community... 
https://github.com/mono/t4/blob/main/Mono.TextTemplating/readme.md

could be useful

